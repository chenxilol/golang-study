
1. 应用于一次多发的场景，即一组协程需要某一个协程完成一些前置准备的情况
# sync.cond 注意事项
1. 被叫方必须持有锁
2. 主叫方可以持有锁，但允许不持有
3. 尽可能的减少无效唤醒

# Mutex 与 RWMutex 作用
1. 并发场景下，通过有锁机制，解决数据竞争的问题

# Mutex 与 RWMutex 的应用场景
1. 协程安全问题
2. 数据竞争问题
 
# 注意事项
1. 尽可能的避免使用锁
2. 应合理使用锁机制， 不要滥用

# sync.Map 
1. 一个线程安全集合，内部通过原子访问和锁机制实现结合的线程安全

# sync.Map 的应用场景
1. 适合读多写少的应用场景
2. 在key值以存在的情况下，可以无修改其value，比普通 map + 锁性能更好
3. 他不试用于计数器以及写比较多的情况，因为他是局部的线程安全，计数器等并不在原子操作里面，会导致计数器出现问题。
   用map + 锁可以解决这个问题，他把整体当做一个原子操作
# sync.pool 的作用
1. 创建一个临时对象池，缓存一组对象用于重复利用，以此来减少内存分配和降低GC的压力

# sync.pool 的应用场景
1.可用于连接池(grpc,客户端，网络连接等)场景

# sync.pool 的注意事项
1. 用户缓存一些创建成本较高，使用比较频繁的对象
2. Pool的长度默认为机器cpu线程数
3. 存储在Pool中的对象随时都有可能在不被通知的情况下被回收
4. 没有什么创建成本的对象，不建议使用对象池

# sync.Once 作用
1. 用于初始化单例资源

# sync.Once 的使用场景
1. 单例场景
2. 仅加载一次的数据懒加载场景

# sync.waitGroup 的作用
1. 等待一组协程完成
2. 工作原理，通过计数器来获取协程的完成情况
3. 启动一个协程时计数器+1， 协程退出时计数器-1
4. 通过wait方法阻塞主协程，等待计数器清零后才能继续执行后续操作

# sync.waitGroup 应用场景
1. 通过协程并行执行一组任务，且任务全部完成后才能进行下一步操作的情况
2. 例如: 汽车的生成，所有零件可以并行生产，只能等所有零件生成完成后，才能组装

# sync.waitGroup 陷阱
1. 协程间传递时需要以指针的方式或者闭包的方式引用waitGroup 对象， 否则将会造成死锁

# sync.Cond 作用
1. 设置一组协程根据条件阻塞，可以根据不同的条件阻塞
2. 可以根据条件唤醒相对应的线程

# sync.Cond 的应用场景
1. 应用于一发多收的场景，即一组协程需要等待某一个协程完成一些前置准备的情况
   用于协调多个 goroutine 之间的执行顺序。它通常与 sync.Mutex 结合使用，以在某个条件满足时通知等待的 goroutine
# sync.Cond 注意事项
1. 被叫方必须持有锁
2. 主叫方可以持有锁，但允许不持有
3. 尽可能减少无效唤醒

# 知识点:
1. sync.WaitGroup{}  
   当用线程组的时候，最后一定不要忘了加上sync.wait, 如果不加，还会出现线程安全问题
2. 在创建结构体时，如果直接声明，没有名字，那么他也是结构体，就是结构体套结构体
3. 在创建读写锁的时候，他们是分别创建的，而且当并发写和并发读的时候，应该用sync.wait，或者用休眠，不然协程还没运行完就退出了
4. 使用并发后,一定要习惯的使用sync.waitGroup ，最后使用wg.wait等待协程操作完成 ，使用并发的时候不要使用io流操作，例如打印等，因为这样会让原本并行的操作，变成串行