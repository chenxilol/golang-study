
1. 应用于一次多发的场景，即一组协程需要某一个协程完成一些前置准备的情况
# sync.cond 注意事项
1. 被叫方必须持有锁
2. 主叫方可以持有锁，但允许不持有
3. 尽可能的减少无效唤醒

# Mutex 与 RWMutex 作用
1. 并发场景下，通过有锁机制，解决数据竞争的问题

# Mutex 与 RWMutex 的应用场景
1. 协程安全问题
2. 数据竞争问题
 
# 注意事项
1. 尽可能的避免使用锁
2. 应合理使用锁机制， 不要滥用

# sync.Map 
1. 一个线程安全集合，内部通过原子访问和锁机制实现结合的线程安全

# sync.Map 的应用场景
1. 适合读多写少的应用场景
2. 在key值以存在的情况下，可以无修改其value，比普通 map + 锁性能更好
3. 他不试用于计数器以及写比较多的情况，因为他是局部的线程安全，计数器等并不在原子操作里面，会导致计数器出现问题。
   用map + 锁可以解决这个问题，他把整体当做一个原子操作
# sync.pool 的作用
1. 创建一个临时对象池，缓存一组对象用于重复利用，以此来减少内存分配和降低GC的压力

# sync.pool 的应用场景
1.可用于连接池(grpc,客户端，网络连接等)场景

# sync.pool 的注意事项
1. 用户缓存一些创建成本较高，使用比较频繁的对象
2. Pool的长度默认为机器cpu线程数
3. 存储在Pool中的对象随时都有可能在不被通知的情况下被回收
4. 没有什么创建成本的对象，不建议使用对象池

# sync.Once 作用
1. 用于初始化单例资源

# sync.Once 的使用场景
1. 单例场景
2. 仅加载一次的数据懒加载场景

# 知识点:
1. sync.WaitGroup{}  
   当用线程组的时候，最后一定不要忘了加上sync.wait, 如果不加，还会出现线程安全问题
2. 在创建结构体时，如果直接声明，没有名字，那么他也是结构体，就是结构体套结构体
3. 在创建读写锁的时候，他们是分别创建的，而且当并发写和并发读的时候，应该用sync.wait，或者用休眠，不然协程还没运行完就退出了
4. 